PROGRAM A_KLI

%STACKSIZE = 4000
%NOLOCKGROUP
%NOPAUSE=ERROR+COMMAND+TPENABLE
%ENVIRONMENT uif
%ENVIRONMENT sysdef
%ENVIRONMENT kclop
%ENVIRONMENT bynam
%ENVIRONMENT fdev
%ENVIRONMENT flbt
%ENVIRONMENT STRNG
%ENVIRONMENT TIM
%ENVIRONMENT REGOPE --GET_REG
%INCLUDE klevccdf
%INCLUDE klevkeys
%INCLUDE klevkmsk


CONST
	cc_success = 0 -- Success status
	cc_xyzwpr = 2 -- Position Register has an XYZWPR
	cc_jntpos = 9 -- Position Register has a JOINTPOS

VAR     --variables declaration with types
	xyz	: XYZWPR
	file_var : FILE
	tmp_int	 : INTEGER
	tmp_str  : STRING[126]
	entry	 : INTEGER

	prg_indx,
	i_val,
	STATUS : INTEGER
	r_val :REAL
	r_flg :BOOLEAN

	loop1	 : BOOLEAN
	loop2	 : BOOLEAN
	cur_tim	: INTEGER
	posext_data :XYZWPREXT


ROUTINE ustaw_screen

BEGIN
    WRITE(CHR(137),CHR(128)); -- Clear the TP USER menu screen
	FORCE_SPMENU(TP_PANEL,SPI_TPUSER,1) -- Force the TP USER menu to be visible

END ustaw_screen


ROUTINE pos_string :STRING
VAR
    pos_r: XYZWPR
    str_r: STRING[126]
    ary_r :ARRAY[6] OF STRING[10]
BEGIN
	pos_r = CURPOS(0,0) --pobranie obecnej pozycji
	CNV_REAL_STR(xyz.x, 2, 3, ary_r[1])
	CNV_REAL_STR(xyz.y, 2, 3, ary_r[2])
	CNV_REAL_STR(xyz.z, 2, 3, ary_r[3])
	CNV_REAL_STR(xyz.w, 2, 3, ary_r[4])
	CNV_REAL_STR(xyz.p, 2, 3, ary_r[5])
	CNV_REAL_STR(xyz.r, 2, 3, ary_r[6])
	str_r = ary_r[1] + ary_r[2] + ary_r[3] + ary_r[4] + ary_r[5] + ary_r[6] --sklejenie pozycji w stringa
    RETURN(str_r)   --zwrocenie wartosci
END pos_string

ROUTINE STOREPOS (reg_id : INTEGER)
VAR
	pos_r: XYZWPR
	stat : INTEGER
BEGIN
	pos_r = CURPOS(0,0) -- Get the current position
	SET_POS_REG(reg_id , pos_r, stat)
END STOREPOS


BEGIN
	ustaw_screen
	
    SET_FILE_ATR(file_var, ATR_IA)
    	-- set attributes of file before its opened (file_id, atr_type, art value)
    	-- ART_IA means Interactively write, 3rd parameter is optional
	SET_VAR(entry, '*SYSTEM*','$HOSTC_CFG[1].$SERVER_PORT', 8000, STATUS)
    	-- syntax : SET_VAR(entry, prog_name, var_name, value, status
		-- tego nie trzeba zrobic, juz ustawione recznie przez TeachPendanta
	WRITE(' VAR status = ', STATUS, CR)
    	-- If file_var is not specified in a WRITE statement the default TPDISPLAY is used
    	-- The reserved word CR, which can be used as a data item, specifies that the next data item 
    	-- to be written to the file_var will start on the next line.

	-- Connect the tag
    WRITE('Program is started.',CR)
	MSG_CONNECT('C1:',STATUS)
    -- Connect a client or server port to another computer for use in Socket Messaging
    -- syntax : MSG_CONNECT (tag, status), status is output
    -- tag is the name of a client port (C1:-C8) or server port (S1:S8)
    -- Status explains the status of the attempted operation. If it is not equal to 0, then an error occurred
	WRITE('Connect status = ',STATUS,CR)
	
	
	loop1 = TRUE
		IF STATUS = 0 THEN
			WHILE loop1 = TRUE DO
				WRITE('Opening file...',CR)
				OPEN FILE file_var('rw','C1:')
                -- Syntax : OPEN FILE file_var ( usage_string, file_string)
                -- 'RWâ€™ :Read write
                --  The file_string identifies a data file name and type, a window or keyboard, or a communication port.
                -- tutaj chyba otwarcie pliku oznacza komunikacje z serwerem i wysylanie/otrzymywanie komunikatow
				STATUS = IO_STATUS(file_var)
                -- Use the IO_STATUS built-in function to verify if the open file operation was successful
				IF STATUS = 0 THEN
					---------------------------------------------------------------------------------------------
					---------------------------------------------------------------------------------------------
					loop2 = TRUE
					tmp_int = 0
					WHILE loop2 = TRUE DO	--wyslanie pozycji 5 razy
						STOREPOS(5)
						tmp_str = pos_string    --uzycie ROUTINE do pobrania obecnej lokalizacji i zrobienia jej na string
						WRITE file_var(tmp_str ::126)
						tmp_int = tmp_int+1
						DELAY 50
						IF tmp_int = 4 THEN
							loop2 = FALSE
						ENDIF
					ENDWHILE


					WRITE('Waiting to read from server...')
					READ file_var(tmp_str::126)	-- The STRING must not be over 127 bytes in length for files or 126 bytes in length for other output
					STATUS = IO_STATUS(file_var)
					WRITE('Read status: ',STATUS,CR)
					WRITE('Read: ',tmp_str,CR)
					loop1 = FALSE

					WRITE('Closed file.',CR)
					CLOSE FILE file_var
				ELSE
					WRITE('Error opening file',CR)
					loop1 = FALSE
				ENDIF						
			ENDWHILE
		ENDIF
	WRITE('Closed file.',CR)
	CLOSE FILE file_var
	MSG_DISCO('C1:',STATUS)
	WRITE('Disconnect status=',STATUS,CR)
END A_KLI

