PROGRAM APOS2
%STACKSIZE = 4000
%NOLOCKGROUP
%NOPAUSE=ERROR+COMMAND+TPENABLE
%ENVIRONMENT uif
%ENVIRONMENT sysdef
%ENVIRONMENT kclop
%ENVIRONMENT bynam
%ENVIRONMENT fdev
%ENVIRONMENT flbt
%ENVIRONMENT STRNG
%ENVIRONMENT TIM
%INCLUDE klevccdf
%INCLUDE klevkeys
%INCLUDE klevkmsk


VAR     --variables declaration with types
	xyz	: XYZWPR
	file_var : FILE
	tmp_int	 : INTEGER
	tmp_str  : STRING[126]
	STATUS	 : INTEGER
	entry	 : INTEGER
	loop1	 : BOOLEAN
	loop2	 : BOOLEAN
	cur_tim	: INTEGER
	ary_tmp :ARRAY[6] OF STRING[10]

BEGIN
	WRITE(CHR(137),CHR(128)); -- Clear the TP USER menu screen
	FORCE_SPMENU(TP_PANEL,SPI_TPUSER,1) -- Force the TP USER menu to be visible
	
	SET_FILE_ATR(file_var, ATR_IA)
    	-- set attributes of file before its opened (file_id, atr_type, art value)
    	-- ART_IA means Interactively write, 3rd parameter is optional
	SET_VAR(entry, '*SYSTEM*','$HOSTC_CFG[1].$SERVER_PORT',8000,STATUS)
    	-- syntax : SET_VAR(entry, prog_name, var_name, value, status
		-- tego nie trzeba zrobic, juz ustawione recznie przez TeachPendanta
	WRITE(' VAR status = ', STATUS, CR)
    	-- If file_var is not specified in a WRITE statement the default TPDISPLAY is used
    	-- The reserved word CR, which can be used as a data item, specifies that the next data item 
    	-- to be written to the file_var will start on the next line.

	-- Connect the tag
    WRITE('Program is started.',CR)
	MSG_CONNECT('C1:',STATUS)
    -- Connect a client or server port to another computer for use in Socket Messaging
    -- syntax : MSG_CONNECT (tag, status), status is output
    -- tag is the name of a client port (C1:-C8) or server port (S1:S8)
    -- Status explains the status of the attempted operation. If it is not equal to 0, then an error occurred
	WRITE('Connect status = ',STATUS,CR)
	
	
	loop1 = TRUE
		IF STATUS = 0 THEN
			WHILE loop1 = TRUE DO
				WRITE('Opening file...',CR)
				OPEN FILE file_var('rw','C1:')
                -- Syntax : OPEN FILE file_var ( usage_string, file_string)
                -- 'RW’ :Read write
                --  The file_string identifies a data file name and type, a window or keyboard, or a communication port.
                -- tutaj chyba otwarcie pliku oznacza komunikacje z serwerem i wysylanie/otrzymywanie komunikatow
				STATUS = IO_STATUS(file_var)
                -- Use the IO_STATUS built-in function to verify if the open file operation was successful
				IF STATUS = 0 THEN
					loop2 = TRUE
					tmp_int = 0
					WHILE loop2 = TRUE DO	--wyslanie pozycji 200 razy bez czekania
						xyz = CURPOS(0,0)
						CNV_REAL_STR(xyz.x, 2, 3, ary_tmp[1])
    					CNV_REAL_STR(xyz.y, 2, 3, ary_tmp[2])
    					CNV_REAL_STR(xyz.z, 2, 3, ary_tmp[3])
						CNV_REAL_STR(xyz.w, 2, 3, ary_tmp[4])
						CNV_REAL_STR(xyz.p, 2, 3, ary_tmp[5])
						CNV_REAL_STR(xyz.r, 2, 3, ary_tmp[6])
    					tmp_str = ary_tmp[1] + ary_tmp[2] + ary_tmp[3] + ary_tmp[4] + ary_tmp[5] + ary_tmp[6]
						WRITE file_var(tmp_str ::126)
						tmp_int = tmp_int+1
						DELAY 50
						IF tmp_int = 5 THEN
							loop2 = FALSE
						ENDIF
					ENDWHILE


					--GET_TIME(cur_tim)					--pobranie obecnego czasu
					--WRITE('Time is: ',cur_tim, CR)	--zrezygnowalem z tego bo nie wyswietla sekund
					--CNV_TIME_STR(cur_tim,tmp_str)
						
					--WRITE file_var(tmp_str ::126)
                    --write 'RunJob' to the file_var (C1:)
					

					WRITE('Waiting to read from server...')
					READ file_var(tmp_str::126)
                    -- The STRING must not be over 127 bytes in length for files or 126 bytes in length for other output
                    -- devices. Otherwise, the program will be aborted with the “STRING TOO LONG” error.
                    -- :: is format specifier
                    -- First Format Specifier: Indicates the total number of characters to be written, including blanks. If
                    -- the format specifier is larger than required for the data, the data is left justified and trailing blanks are
                    -- added. If the format specifier is smaller than required, the STRING is truncated on the right.
					STATUS = IO_STATUS(file_var)
					WRITE('Read status: ',STATUS,CR)
					WRITE('Read: ',tmp_str,CR)
					loop1 = FALSE


					WRITE('Closed file.',CR)
					CLOSE FILE file_var
				ELSE
					WRITE('Error opening file',CR)
					loop1 = FALSE
				ENDIF						
			ENDWHILE
		ENDIF
	WRITE('Closed file.',CR)
	CLOSE FILE file_var
	MSG_DISCO('C1:',STATUS)
	WRITE('Disconnect status=',STATUS,CR)
END APOS2

